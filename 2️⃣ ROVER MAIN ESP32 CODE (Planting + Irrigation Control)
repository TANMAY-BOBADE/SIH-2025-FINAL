#include <WiFi.h>
#include <ESP32Servo.h>
#include <DHT.h>
#include <FirebaseESP32.h>

// =================== 1. PHONE HOTSPOT CREDENTIALS ===================
// âš ï¸ REPLACE WITH YOUR MOBILE HOTSPOT DETAILS
const char* ssid = "YOUR_HOTSPOT_NAME";
const char* password = "YOUR_HOTSPOT_PASSWORD";

// =================== 2. FIREBASE CONFIG ===================
#define DATABASE_URL "https://kissan-agriculture-sih-default-rtdb.asia-southeast1.firebasedatabase.app"
#define DATABASE_SECRET "YOUR_DATABASE_SECRET_HERE"

// =================== PINS (MATCHING YOUR DOCS) ===================
#define DISC_SERVO_PIN 13
#define FLAP_SERVO_PIN 15
// Rack & Pinion Motors
#define MOTOR_A_FWD 26
#define MOTOR_A_BWD 27
#define MOTOR_B_FWD 14
#define MOTOR_B_BWD 12
#define MOTOR_ENA 25
#define MOTOR_ENB 33
// Sensors & Pump
#define DHTPIN 4
#define DHTTYPE DHT11
#define SOIL_MOISTURE_PIN 34
#define PUMP_RELAY_PIN 32

// =================== OBJECTS ===================
Servo discServo;
Servo flapServo;
DHT dht(DHTPIN, DHTTYPE);
FirebaseData firebaseData;
FirebaseAuth auth;
FirebaseConfig config;

// =================== VARIABLES ===================
int currentDiscAngle = 0;
bool plantationRunning = false;
bool irrigationRunning = false;
unsigned long sequenceStartTime = 0;
int plantationStep = 0;
float calculatedWaterDuration = 0;
float soilMoistureReading = 0;
String selectedCrop = "potato";
String selectedStage = "germination";

// Default Thresholds (Will update from Firebase)
struct Thresholds {
  float moisture_min; float moisture_max;
} currentThresholds = {48, 70};

unsigned long lastSensorUpload = 0;
const unsigned long SENSOR_INTERVAL = 7000; // Upload every 7 seconds

void setup() {
  Serial.begin(115200);
  Serial.println("\n===== ROVER MAIN CONTROLLER STARTING =====");
  
  // 1. Init Pins
  pinMode(MOTOR_A_FWD, OUTPUT); pinMode(MOTOR_A_BWD, OUTPUT);
  pinMode(MOTOR_B_FWD, OUTPUT); pinMode(MOTOR_B_BWD, OUTPUT);
  pinMode(MOTOR_ENA, OUTPUT);   pinMode(MOTOR_ENB, OUTPUT);
  pinMode(PUMP_RELAY_PIN, OUTPUT);
  digitalWrite(PUMP_RELAY_PIN, LOW); // Pump OFF
  
  // 2. Init Servos
  discServo.attach(DISC_SERVO_PIN);
  flapServo.attach(FLAP_SERVO_PIN);
  discServo.write(90); // Home position
  flapServo.write(0);  // Closed
  
  dht.begin();
  
  // 3. Connect to Phone Hotspot
  WiFi.begin(ssid, password);
  Serial.print("Connecting to Internet");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println("\nâœ“ Connected to Hotspot!");
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());
  
  // 4. Init Firebase
  config.database_url = DATABASE_URL;
  config.signer.tokens.legacy_token = DATABASE_SECRET;
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  Serial.println("ðŸ”¥ Firebase Initialized");
}

void loop() {
  unsigned long currentMillis = millis();

  // Task 1: Upload Sensor Data
  if (currentMillis - lastSensorUpload >= SENSOR_INTERVAL) {
    lastSensorUpload = currentMillis;
    uploadSensorData();
  }
  
  // Task 2: Listen for Commands (Plant/Irrigate)
  checkFirebaseCommands();
  
  // Task 3: Run Automation Sequences
  if (plantationRunning) runPlantationSequence();
  if (irrigationRunning) runIrrigationSequence();
}

void checkFirebaseCommands() {
  // A. Check Configuration
  if (Firebase.getString(firebaseData, "/rover/current_config/crop")) {
    selectedCrop = firebaseData.stringData();
  }
  if (Firebase.getString(firebaseData, "/rover/current_config/stage")) {
    selectedStage = firebaseData.stringData();
  }
  
  // B. Check for Plantation Command
  // We check the 'commands' queue or the last command status
  // For this setup, we look for new commands in the queue
  // (Simplified logic: Checking a flag for robustness in student projects)
  
  // Note: The Dashboard pushes to /rover/commands. 
  // Ideally, use stream, but polling logic for flag works reliably:
  // We assume the dashboard sets a "trigger" flag somewhere or we poll the latest command.
  
  // LISTENING TO QUEUE (Simplified)
  // Check specific trigger flags if you set them up, or use this structure:
  // NOTE: Ensure your dashboard JS sets "/rover/controls/plantation_active" to TRUE when clicked.
  if (Firebase.getBool(firebaseData, "/rover/controls/plantation_active")) {
    if (firebaseData.boolData() == true && !plantationRunning) {
        startPlantationSequence();
        // Reset flag immediately
        Firebase.setBool(firebaseData, "/rover/controls/plantation_active", false);
    }
  }

  // Check Irrigation Command
  if (Firebase.getBool(firebaseData, "/rover/controls/irrigation_active")) {
    if (firebaseData.boolData() == true && !irrigationRunning) {
        startIrrigationSequence();
        Firebase.setBool(firebaseData, "/rover/controls/irrigation_active", false);
    }
  }
}

void uploadSensorData() {
  float temp = dht.readTemperature();
  float humidity = dht.readHumidity();
  float moisture = readSoilMoisture();
  
  if (isnan(temp) || isnan(humidity)) {
    Serial.println("âœ— Sensor failed");
    return;
  }
  
  Serial.printf("ðŸ“Š Rover Sensors: T=%.1f H=%.1f M=%.1f\n", temp, humidity, moisture);
  
  Firebase.setFloat(firebaseData, "/rover/sensors/temperature", temp);
  Firebase.setFloat(firebaseData, "/rover/sensors/humidity", humidity);
  Firebase.setFloat(firebaseData, "/rover/sensors/moisture", moisture);
  Firebase.setInt(firebaseData, "/rover/sensors/timestamp", millis());
}

float readSoilMoisture() {
  int rawValue = analogRead(SOIL_MOISTURE_PIN);
  // Adjust 3000 (Dry) and 1000 (Wet) based on calibration
  float moisture = map(rawValue, 3000, 1000, 0, 100); 
  return constrain(moisture, 0, 100);
}

// --- PLANTATION LOGIC (MATCHING YOUR DOCS) ---
void startPlantationSequence() {
  Serial.println("ðŸš€ STARTED: Plantation Sequence");
  plantationRunning = true;
  plantationStep = 1;
  sequenceStartTime = millis();
  Firebase.setBool(firebaseData, "/rover/plantation/sequence_running", true);
}

void runPlantationSequence() {
  unsigned long elapsed = millis() - sequenceStartTime;
  
  switch (plantationStep) {
    case 1: // Rack DOWN
      Serial.println("Step 1: Rack Down");
      moveRackDown();
      sequenceStartTime = millis();
      plantationStep = 2;
      break;
      
    case 2: // Wait then Rotate Disc
      if (elapsed >= 500) {
        Serial.println("Step 2: Disc Rotate");
        rotateDisc60Degrees();
        sequenceStartTime = millis();
        plantationStep = 3;
      }
      break;
      
    case 3: // Wait then Open Flap (Insert Sensor)
      if (elapsed >= 500) {
        Serial.println("Step 3: Open Flap (Sensing...)");
        flapServo.write(90); // Open
        
        // READ SOIL WHILE IN GROUND
        soilMoistureReading = readSoilMoisture();
        calculateWaterDuration(); // Logic to decide how much water needed
        
        sequenceStartTime = millis();
        plantationStep = 4;
      }
      break;
      
    case 4: // Wait 8s then Close Flap
      if (elapsed >= 8000) {
        Serial.println("Step 4: Close Flap");
        flapServo.write(0); // Close
        sequenceStartTime = millis();
        plantationStep = 5;
      }
      break;
      
    case 5: // Wait then Rack UP
      if (elapsed >= 500) {
        Serial.println("Step 5: Rack Up");
        moveRackUp();
        sequenceStartTime = millis();
        plantationStep = 6;
      }
      break;
      
    case 6: // Finish
      if (elapsed >= 2000) {
        Serial.println("âœ… PLANTATION COMPLETE");
        stopMotors();
        plantationRunning = false;
        plantationStep = 0;
        Firebase.setBool(firebaseData, "/rover/plantation/sequence_running", false);
      }
      break;
  }
}

// --- IRRIGATION LOGIC ---
void startIrrigationSequence() {
  Serial.println("ðŸš€ STARTED: Irrigation Sequence");
  irrigationRunning = true;
  digitalWrite(PUMP_RELAY_PIN, HIGH); // Pump ON
  sequenceStartTime = millis();
}

void runIrrigationSequence() {
  // calculatedWaterDuration is set by calculateWaterDuration() function
  // If manual start, use default 3 seconds
  if (calculatedWaterDuration == 0) calculatedWaterDuration = 3000; 
  
  if (millis() - sequenceStartTime >= calculatedWaterDuration) {
    Serial.println("âœ… IRRIGATION COMPLETE");
    digitalWrite(PUMP_RELAY_PIN, LOW); // Pump OFF
    irrigationRunning = false;
  }
}

// --- MOTOR HELPERS (Rack & Pinion) ---
void moveRackDown() {
  digitalWrite(MOTOR_A_FWD, LOW); digitalWrite(MOTOR_A_BWD, HIGH);
  digitalWrite(MOTOR_B_FWD, HIGH); digitalWrite(MOTOR_B_BWD, LOW);
  analogWrite(MOTOR_ENA, 255); analogWrite(MOTOR_ENB, 255);
}
void moveRackUp() {
  digitalWrite(MOTOR_A_FWD, HIGH); digitalWrite(MOTOR_A_BWD, LOW);
  digitalWrite(MOTOR_B_FWD, LOW); digitalWrite(MOTOR_B_BWD, HIGH);
  analogWrite(MOTOR_ENA, 255); analogWrite(MOTOR_ENB, 255);
}
void stopMotors() {
  digitalWrite(MOTOR_A_FWD, LOW); digitalWrite(MOTOR_A_BWD, LOW);
  digitalWrite(MOTOR_B_FWD, LOW); digitalWrite(MOTOR_B_BWD, LOW);
}
void rotateDisc60Degrees() {
  discServo.write(180); delay(300);
  discServo.write(90);
  currentDiscAngle = (currentDiscAngle + 60) % 360;
}
void calculateWaterDuration() {
  // Simple logic: wetter soil = less time
  // This fetches thresholds from DB in a full implementation
  // Here we use a simple scalar for the demo
  if (soilMoistureReading < currentThresholds.moisture_min) {
      calculatedWaterDuration = 5000; // 5 seconds if dry
  } else {
      calculatedWaterDuration = 2000; // 2 seconds if moist
  }
}
